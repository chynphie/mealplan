{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport * as React from 'react';\nimport { Animated, I18nManager, Keyboard, PanResponder, StyleSheet, View } from 'react-native';\nimport { useAnimatedValue } from './useAnimatedValue';\nconst DEAD_ZONE = 12;\nconst DefaultTransitionSpec = {\n  timing: Animated.spring,\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true\n};\nexport function PanResponderAdapter(_ref) {\n  let {\n    layout,\n    keyboardDismissMode = 'auto',\n    swipeEnabled = true,\n    navigationState,\n    onIndexChange,\n    onSwipeStart,\n    onSwipeEnd,\n    children,\n    style,\n    animationEnabled = false\n  } = _ref;\n  const {\n    routes,\n    index\n  } = navigationState;\n  const panX = useAnimatedValue(0);\n  const listenersRef = React.useRef([]);\n  const navigationStateRef = React.useRef(navigationState);\n  const layoutRef = React.useRef(layout);\n  const onIndexChangeRef = React.useRef(onIndexChange);\n  const currentIndexRef = React.useRef(index);\n  const pendingIndexRef = React.useRef();\n  const swipeVelocityThreshold = 0.15;\n  const swipeDistanceThreshold = layout.width / 1.75;\n  const jumpToIndex = React.useCallback(function (index) {\n    let animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : animationEnabled;\n    const offset = -index * layoutRef.current.width;\n    const {\n      timing,\n      ...transitionConfig\n    } = DefaultTransitionSpec;\n    if (animate) {\n      Animated.parallel([timing(panX, {\n        ...transitionConfig,\n        toValue: offset,\n        useNativeDriver: false\n      })]).start(_ref2 => {\n        let {\n          finished\n        } = _ref2;\n        if (finished) {\n          onIndexChangeRef.current(index);\n          pendingIndexRef.current = undefined;\n        }\n      });\n      pendingIndexRef.current = index;\n    } else {\n      panX.setValue(offset);\n      onIndexChangeRef.current(index);\n      pendingIndexRef.current = undefined;\n    }\n  }, [animationEnabled, panX]);\n  React.useEffect(() => {\n    navigationStateRef.current = navigationState;\n    layoutRef.current = layout;\n    onIndexChangeRef.current = onIndexChange;\n  });\n  React.useEffect(() => {\n    const offset = -navigationStateRef.current.index * layout.width;\n    panX.setValue(offset);\n  }, [layout.width, panX]);\n  React.useEffect(() => {\n    if (keyboardDismissMode === 'auto') {\n      Keyboard.dismiss();\n    }\n    if (layout.width && currentIndexRef.current !== index) {\n      currentIndexRef.current = index;\n      jumpToIndex(index);\n    }\n  }, [jumpToIndex, keyboardDismissMode, layout.width, index]);\n  const isMovingHorizontally = (_, gestureState) => {\n    return Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2);\n  };\n  const canMoveScreen = (event, gestureState) => {\n    if (swipeEnabled === false) {\n      return false;\n    }\n    const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n    return isMovingHorizontally(event, gestureState) && (diffX >= DEAD_ZONE && currentIndexRef.current > 0 || diffX <= -DEAD_ZONE && currentIndexRef.current < routes.length - 1);\n  };\n  const startGesture = () => {\n    onSwipeStart === null || onSwipeStart === void 0 ? void 0 : onSwipeStart();\n    if (keyboardDismissMode === 'on-drag') {\n      Keyboard.dismiss();\n    }\n    panX.stopAnimation();\n    // @ts-expect-error: _value is private, but docs use it as well\n    panX.setOffset(panX._value);\n  };\n  const respondToGesture = (_, gestureState) => {\n    const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n    if (\n    // swiping left\n    diffX > 0 && index <= 0 ||\n    // swiping right\n    diffX < 0 && index >= routes.length - 1) {\n      return;\n    }\n    if (layout.width) {\n      // @ts-expect-error: _offset is private, but docs use it as well\n      const position = (panX._offset + diffX) / -layout.width;\n      const next = position > index ? Math.ceil(position) : Math.floor(position);\n      if (next !== index) {\n        listenersRef.current.forEach(listener => listener(next));\n      }\n    }\n    panX.setValue(diffX);\n  };\n  const finishGesture = (_, gestureState) => {\n    panX.flattenOffset();\n    onSwipeEnd === null || onSwipeEnd === void 0 ? void 0 : onSwipeEnd();\n    const currentIndex = typeof pendingIndexRef.current === 'number' ? pendingIndexRef.current : currentIndexRef.current;\n    let nextIndex = currentIndex;\n    if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy) && (Math.abs(gestureState.dx) > swipeDistanceThreshold || Math.abs(gestureState.vx) > swipeVelocityThreshold)) {\n      nextIndex = Math.round(Math.min(Math.max(0, I18nManager.isRTL ? currentIndex + gestureState.dx / Math.abs(gestureState.dx) : currentIndex - gestureState.dx / Math.abs(gestureState.dx)), routes.length - 1));\n      currentIndexRef.current = nextIndex;\n    }\n    if (!isFinite(nextIndex)) {\n      nextIndex = currentIndex;\n    }\n    jumpToIndex(nextIndex, true);\n  };\n\n  // TODO: use the listeners\n  const addEnterListener = React.useCallback(listener => {\n    listenersRef.current.push(listener);\n    return () => {\n      const index = listenersRef.current.indexOf(listener);\n      if (index > -1) {\n        listenersRef.current.splice(index, 1);\n      }\n    };\n  }, []);\n  const jumpTo = React.useCallback(key => {\n    const index = navigationStateRef.current.routes.findIndex(route => route.key === key);\n    jumpToIndex(index);\n  }, [jumpToIndex]);\n  const panResponder = PanResponder.create({\n    onMoveShouldSetPanResponder: canMoveScreen,\n    onMoveShouldSetPanResponderCapture: canMoveScreen,\n    onPanResponderGrant: startGesture,\n    onPanResponderMove: respondToGesture,\n    onPanResponderTerminate: finishGesture,\n    onPanResponderRelease: finishGesture,\n    onPanResponderTerminationRequest: () => true\n  });\n  const maxTranslate = layout.width * (routes.length - 1);\n  const translateX = Animated.multiply(panX.interpolate({\n    inputRange: [-maxTranslate, 0],\n    outputRange: [-maxTranslate, 0],\n    extrapolate: 'clamp'\n  }), I18nManager.isRTL ? -1 : 1);\n  const position = React.useMemo(() => layout.width ? Animated.divide(panX, -layout.width) : null, [layout.width, panX]);\n  return children({\n    position: position ?? new Animated.Value(index),\n    addEnterListener,\n    jumpTo,\n    render: children => /*#__PURE__*/React.createElement(Animated.View, _extends({\n      style: [styles.sheet, layout.width ? {\n        width: routes.length * layout.width,\n        transform: [{\n          translateX\n        }]\n      } : null, style]\n    }, panResponder.panHandlers), React.Children.map(children, (child, i) => {\n      const route = routes[i];\n      const focused = i === index;\n      return /*#__PURE__*/React.createElement(View, {\n        key: route.key,\n        style: layout.width ? {\n          width: layout.width\n        } : focused ? StyleSheet.absoluteFill : null\n      }, focused || layout.width ? child : null);\n    }))\n  });\n}\nconst styles = StyleSheet.create({\n  sheet: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'stretch'\n  }\n});","map":{"version":3,"names":["React","Animated","I18nManager","Keyboard","PanResponder","StyleSheet","View","useAnimatedValue","DEAD_ZONE","DefaultTransitionSpec","timing","spring","stiffness","damping","mass","overshootClamping","PanResponderAdapter","_ref","layout","keyboardDismissMode","swipeEnabled","navigationState","onIndexChange","onSwipeStart","onSwipeEnd","children","style","animationEnabled","routes","index","panX","listenersRef","useRef","navigationStateRef","layoutRef","onIndexChangeRef","currentIndexRef","pendingIndexRef","swipeVelocityThreshold","swipeDistanceThreshold","width","jumpToIndex","useCallback","animate","arguments","length","undefined","offset","current","transitionConfig","parallel","toValue","useNativeDriver","start","_ref2","finished","setValue","useEffect","dismiss","isMovingHorizontally","_","gestureState","Math","abs","dx","dy","vx","vy","canMoveScreen","event","diffX","isRTL","startGesture","stopAnimation","setOffset","_value","respondToGesture","position","_offset","next","ceil","floor","forEach","listener","finishGesture","flattenOffset","currentIndex","nextIndex","round","min","max","isFinite","addEnterListener","push","indexOf","splice","jumpTo","key","findIndex","route","panResponder","create","onMoveShouldSetPanResponder","onMoveShouldSetPanResponderCapture","onPanResponderGrant","onPanResponderMove","onPanResponderTerminate","onPanResponderRelease","onPanResponderTerminationRequest","maxTranslate","translateX","multiply","interpolate","inputRange","outputRange","extrapolate","useMemo","divide","Value","render","createElement","_extends","styles","sheet","transform","panHandlers","Children","map","child","i","focused","absoluteFill","flex","flexDirection","alignItems"],"sources":["/Users/chynphieyang/MyWebPage/node_modules/react-native-tab-view/src/PanResponderAdapter.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  GestureResponderEvent,\n  I18nManager,\n  Keyboard,\n  PanResponder,\n  PanResponderGestureState,\n  StyleSheet,\n  View,\n} from 'react-native';\n\nimport type {\n  EventEmitterProps,\n  Layout,\n  Listener,\n  NavigationState,\n  PagerProps,\n  Route,\n} from './types';\nimport { useAnimatedValue } from './useAnimatedValue';\n\ntype Props<T extends Route> = PagerProps & {\n  layout: Layout;\n  onIndexChange: (index: number) => void;\n  navigationState: NavigationState<T>;\n  children: (\n    props: EventEmitterProps & {\n      // Animated value which represents the state of current index\n      // It can include fractional digits as it represents the intermediate value\n      position: Animated.AnimatedInterpolation<number>;\n      // Function to actually render the content of the pager\n      // The parent component takes care of rendering\n      render: (children: React.ReactNode) => React.ReactNode;\n      // Callback to call when switching the tab\n      // The tab switch animation is performed even if the index in state is unchanged\n      jumpTo: (key: string) => void;\n    }\n  ) => React.ReactElement;\n};\n\nconst DEAD_ZONE = 12;\n\nconst DefaultTransitionSpec = {\n  timing: Animated.spring,\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n};\n\nexport function PanResponderAdapter<T extends Route>({\n  layout,\n  keyboardDismissMode = 'auto',\n  swipeEnabled = true,\n  navigationState,\n  onIndexChange,\n  onSwipeStart,\n  onSwipeEnd,\n  children,\n  style,\n  animationEnabled = false,\n}: Props<T>) {\n  const { routes, index } = navigationState;\n\n  const panX = useAnimatedValue(0);\n\n  const listenersRef = React.useRef<Listener[]>([]);\n\n  const navigationStateRef = React.useRef(navigationState);\n  const layoutRef = React.useRef(layout);\n  const onIndexChangeRef = React.useRef(onIndexChange);\n\n  const currentIndexRef = React.useRef(index);\n  const pendingIndexRef = React.useRef<number>();\n\n  const swipeVelocityThreshold = 0.15;\n  const swipeDistanceThreshold = layout.width / 1.75;\n\n  const jumpToIndex = React.useCallback(\n    (index: number, animate = animationEnabled) => {\n      const offset = -index * layoutRef.current.width;\n\n      const { timing, ...transitionConfig } = DefaultTransitionSpec;\n\n      if (animate) {\n        Animated.parallel([\n          timing(panX, {\n            ...transitionConfig,\n            toValue: offset,\n            useNativeDriver: false,\n          }),\n        ]).start(({ finished }) => {\n          if (finished) {\n            onIndexChangeRef.current(index);\n            pendingIndexRef.current = undefined;\n          }\n        });\n        pendingIndexRef.current = index;\n      } else {\n        panX.setValue(offset);\n        onIndexChangeRef.current(index);\n        pendingIndexRef.current = undefined;\n      }\n    },\n    [animationEnabled, panX]\n  );\n\n  React.useEffect(() => {\n    navigationStateRef.current = navigationState;\n    layoutRef.current = layout;\n    onIndexChangeRef.current = onIndexChange;\n  });\n\n  React.useEffect(() => {\n    const offset = -navigationStateRef.current.index * layout.width;\n\n    panX.setValue(offset);\n  }, [layout.width, panX]);\n\n  React.useEffect(() => {\n    if (keyboardDismissMode === 'auto') {\n      Keyboard.dismiss();\n    }\n\n    if (layout.width && currentIndexRef.current !== index) {\n      currentIndexRef.current = index;\n      jumpToIndex(index);\n    }\n  }, [jumpToIndex, keyboardDismissMode, layout.width, index]);\n\n  const isMovingHorizontally = (\n    _: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    return (\n      Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) &&\n      Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2)\n    );\n  };\n\n  const canMoveScreen = (\n    event: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    if (swipeEnabled === false) {\n      return false;\n    }\n\n    const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n\n    return (\n      isMovingHorizontally(event, gestureState) &&\n      ((diffX >= DEAD_ZONE && currentIndexRef.current > 0) ||\n        (diffX <= -DEAD_ZONE && currentIndexRef.current < routes.length - 1))\n    );\n  };\n\n  const startGesture = () => {\n    onSwipeStart?.();\n\n    if (keyboardDismissMode === 'on-drag') {\n      Keyboard.dismiss();\n    }\n\n    panX.stopAnimation();\n    // @ts-expect-error: _value is private, but docs use it as well\n    panX.setOffset(panX._value);\n  };\n\n  const respondToGesture = (\n    _: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n\n    if (\n      // swiping left\n      (diffX > 0 && index <= 0) ||\n      // swiping right\n      (diffX < 0 && index >= routes.length - 1)\n    ) {\n      return;\n    }\n\n    if (layout.width) {\n      // @ts-expect-error: _offset is private, but docs use it as well\n      const position = (panX._offset + diffX) / -layout.width;\n      const next =\n        position > index ? Math.ceil(position) : Math.floor(position);\n\n      if (next !== index) {\n        listenersRef.current.forEach((listener) => listener(next));\n      }\n    }\n\n    panX.setValue(diffX);\n  };\n\n  const finishGesture = (\n    _: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    panX.flattenOffset();\n\n    onSwipeEnd?.();\n\n    const currentIndex =\n      typeof pendingIndexRef.current === 'number'\n        ? pendingIndexRef.current\n        : currentIndexRef.current;\n\n    let nextIndex = currentIndex;\n\n    if (\n      Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&\n      Math.abs(gestureState.vx) > Math.abs(gestureState.vy) &&\n      (Math.abs(gestureState.dx) > swipeDistanceThreshold ||\n        Math.abs(gestureState.vx) > swipeVelocityThreshold)\n    ) {\n      nextIndex = Math.round(\n        Math.min(\n          Math.max(\n            0,\n            I18nManager.isRTL\n              ? currentIndex + gestureState.dx / Math.abs(gestureState.dx)\n              : currentIndex - gestureState.dx / Math.abs(gestureState.dx)\n          ),\n          routes.length - 1\n        )\n      );\n\n      currentIndexRef.current = nextIndex;\n    }\n\n    if (!isFinite(nextIndex)) {\n      nextIndex = currentIndex;\n    }\n\n    jumpToIndex(nextIndex, true);\n  };\n\n  // TODO: use the listeners\n  const addEnterListener = React.useCallback((listener: Listener) => {\n    listenersRef.current.push(listener);\n\n    return () => {\n      const index = listenersRef.current.indexOf(listener);\n\n      if (index > -1) {\n        listenersRef.current.splice(index, 1);\n      }\n    };\n  }, []);\n\n  const jumpTo = React.useCallback(\n    (key: string) => {\n      const index = navigationStateRef.current.routes.findIndex(\n        (route: { key: string }) => route.key === key\n      );\n\n      jumpToIndex(index);\n    },\n    [jumpToIndex]\n  );\n\n  const panResponder = PanResponder.create({\n    onMoveShouldSetPanResponder: canMoveScreen,\n    onMoveShouldSetPanResponderCapture: canMoveScreen,\n    onPanResponderGrant: startGesture,\n    onPanResponderMove: respondToGesture,\n    onPanResponderTerminate: finishGesture,\n    onPanResponderRelease: finishGesture,\n    onPanResponderTerminationRequest: () => true,\n  });\n\n  const maxTranslate = layout.width * (routes.length - 1);\n  const translateX = Animated.multiply(\n    panX.interpolate({\n      inputRange: [-maxTranslate, 0],\n      outputRange: [-maxTranslate, 0],\n      extrapolate: 'clamp',\n    }),\n    I18nManager.isRTL ? -1 : 1\n  );\n\n  const position = React.useMemo(\n    () => (layout.width ? Animated.divide(panX, -layout.width) : null),\n    [layout.width, panX]\n  );\n\n  return children({\n    position: position ?? new Animated.Value(index),\n    addEnterListener,\n    jumpTo,\n    render: (children) => (\n      <Animated.View\n        style={[\n          styles.sheet,\n          layout.width\n            ? {\n                width: routes.length * layout.width,\n                transform: [{ translateX }],\n              }\n            : null,\n          style,\n        ]}\n        {...panResponder.panHandlers}\n      >\n        {React.Children.map(children, (child, i) => {\n          const route = routes[i];\n          const focused = i === index;\n\n          return (\n            <View\n              key={route.key}\n              style={\n                layout.width\n                  ? { width: layout.width }\n                  : focused\n                  ? StyleSheet.absoluteFill\n                  : null\n              }\n            >\n              {focused || layout.width ? child : null}\n            </View>\n          );\n        })}\n      </Animated.View>\n    ),\n  });\n}\n\nconst styles = StyleSheet.create({\n  sheet: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'stretch',\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}